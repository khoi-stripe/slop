<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Grid Test</title>
  <style>
    * { box-sizing: border-box; }
    html, body { height: 100%; margin: 0; overflow: hidden; }
    body {
      font-family: ui-sans-serif, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      background: #c1121f;
      color: #e8ecf6;
    }

    .app {
      width: 100vw;
      height: 100vh;
      padding: clamp(8px, 1.5cqi, 24px);
      display: grid;
      place-items: center;
      /* Enable container queries */
      container-type: size;
    }

    .board {
      display: grid;
      grid-template-columns: repeat(6, 1fr);
      grid-template-rows: repeat(5, 1fr);
      gap: clamp(6px, 1cqi, 16px);
      padding: clamp(4px, 0.6cqi, 12px);
      background: rgba(0,0,0,0.1);
      /* Fit within container, maintaining 16:9 */
      max-height: 100%;
      max-width: 100%;
      width: min(100%, calc(100cqh * (16 / 9)));
      height: min(100%, calc(100cqw * (9 / 16)));
      aspect-ratio: 16 / 9;
    }

    .tile {
      background: rgba(255,255,255,0.1);
      border: 1px solid rgba(255,255,255,0.2);
      border-radius: 4px;
      display: grid;
      place-items: center;
      text-align: center;
      padding: clamp(8px, 1.5cqi, 24px);
      font-size: clamp(14px, 1.25cqi, 40px);
      font-weight: 700;
      line-height: 1.2;
      transition: box-shadow 120ms ease, transform 80ms ease, background 180ms ease, opacity 180ms ease;
      position: relative; /* needed for absolute positioned gremlin */
    }

    .tile.active {
      box-shadow: 0 0 0 3px rgba(251,191,36,0.45), 0 0 24px 4px rgba(245,158,11,0.35);
      background: rgba(255,255,255,0.15);
    }

    .tile.selected {
      background: #E1B033;
      color: #000000;
      opacity: 1;
    }

    .tile.disabled {
      opacity: 0.2;
    }

    /* Gremlin overlay */
    .tile .gremlin-img {
      display: none;
      position: absolute;
      inset: clamp(8px, 1.5cqi, 24px); /* match tile padding */
      width: calc(100% - 2 * clamp(8px, 1.5cqi, 24px));
      height: calc(100% - 2 * clamp(8px, 1.5cqi, 24px));
      object-fit: contain;
      border-radius: 4px;
      z-index: 10;
    }

    .tile.gremlin .gremlin-img {
      display: block;
    }

    .tile.gremlin .tile-text {
      display: none;
    }

    .center {
      grid-column: 2 / span 4;
      grid-row: 2 / span 3;
      background: radial-gradient(circle, #1c2347, #12162a);
      border: 1px solid rgba(255,255,255,0.3);
      padding: 0;
      overflow: hidden;
      display: grid;
      place-items: center;
    }
    
    .center img {
      width: 100%;
      height: 100%;
      object-fit: contain;
      max-width: 100%;
      max-height: 100%;
    }

    /* Start overlay */
    #startOverlay {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.9);
      display: grid;
      place-items: center;
      z-index: 1000;
      cursor: pointer;
    }

    #startOverlay .message {
      font-size: 32px;
      font-weight: 700;
      color: #E1B033;
      text-align: center;
      padding: 32px;
    }

    #startOverlay.hidden {
      display: none;
    }
  </style>
</head>
<body>
  <div id="startOverlay">
    <div class="message">Click to Start</div>
  </div>
  <div class="app">
    <div class="board" id="board">
      <!-- Perimeter tiles -->
      <div class="tile" style="grid-column: 1; grid-row: 1;">1</div>
      <div class="tile" style="grid-column: 2; grid-row: 1;">2</div>
      <div class="tile" style="grid-column: 3; grid-row: 1;">3</div>
      <div class="tile" style="grid-column: 4; grid-row: 1;">4</div>
      <div class="tile" style="grid-column: 5; grid-row: 1;">5</div>
      <div class="tile" style="grid-column: 6; grid-row: 1;">6</div>
      
      <div class="tile" style="grid-column: 6; grid-row: 2;">7</div>
      <div class="tile" style="grid-column: 6; grid-row: 3;">8</div>
      <div class="tile" style="grid-column: 6; grid-row: 4;">9</div>
      
      <div class="tile" style="grid-column: 6; grid-row: 5;">10</div>
      <div class="tile" style="grid-column: 5; grid-row: 5;">11</div>
      <div class="tile" style="grid-column: 4; grid-row: 5;">12</div>
      <div class="tile" style="grid-column: 3; grid-row: 5;">13</div>
      <div class="tile" style="grid-column: 2; grid-row: 5;">14</div>
      <div class="tile" style="grid-column: 1; grid-row: 5;">15</div>
      
      <div class="tile" style="grid-column: 1; grid-row: 4;">16</div>
      <div class="tile" style="grid-column: 1; grid-row: 3;">17</div>
      <div class="tile" style="grid-column: 1; grid-row: 2;">18</div>
      
      <!-- Center tile -->
      <div class="center" id="center">
        <img id="centerImage" alt="Center" />
      </div>
    </div>
  </div>

  <script>
    // Configuration system
    let DEFAULT_CONFIG = {
      centerImageUrl: "images/gremlin_center.png",
      gremlin: { title: "AI Gremlin", imageUrl: "" },
      options: [
        { id: "A", title: "Option A" },
        { id: "B", title: "Option B" },
        { id: "C", title: "Option C" },
        { id: "D", title: "Option D" },
        { id: "E", title: "Option E" },
        { id: "F", title: "Option F" }
      ]
    };

    const STORAGE_KEY = "pyl_config_v1";

    async function tryLoadDefaultFromConfigJson() {
      try {
        const res = await fetch('./config.json', { cache: 'no-store' });
        if (!res.ok) return;
        const json = await res.json();
        if (!json || !Array.isArray(json.options) || json.options.length !== 6) return;
        DEFAULT_CONFIG = json;
      } catch {}
    }

    function loadConfig() {
      try {
        const raw = localStorage.getItem(STORAGE_KEY);
        if (!raw) return structuredClone(DEFAULT_CONFIG);
        const cfg = JSON.parse(raw);
        if (!cfg.options || cfg.options.length !== 6) return structuredClone(DEFAULT_CONFIG);
        return cfg;
      } catch (e) {
        return structuredClone(DEFAULT_CONFIG);
      }
    }

    let config;
    const centerImg = document.getElementById("centerImage");

    // Get all perimeter tiles (numbered 1-18)
    const tiles = [];
    for (let i = 1; i <= 18; i++) {
      const tile = document.querySelector(`.tile:nth-child(${i})`);
      if (tile) tiles.push(tile);
    }

    function assignTitles() {
      // Assign 6 options to 18 tiles (3 tiles per option)
      const optionIds = config.options.map(o => o.id);
      const indices = Array.from({length: 18}, (_, i) => i);
      // Shuffle
      for (let i = indices.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [indices[i], indices[j]] = [indices[j], indices[i]];
      }
      
      const byId = Object.fromEntries(config.options.map(o => [o.id, o]));
      
      for (let k = 0; k < optionIds.length; k++) {
        for (let rep = 0; rep < 3; rep++) {
          const tileIdx = indices[k * 3 + rep];
          const tile = tiles[tileIdx];
          const opt = byId[optionIds[k]];
          
          // Wrap text in span for gremlin hiding
          const textSpan = document.createElement('span');
          textSpan.className = 'tile-text';
          textSpan.textContent = opt.title;
          tile.textContent = '';
          tile.appendChild(textSpan);
          
          // Add gremlin image holder
          const gimg = document.createElement('img');
          gimg.className = 'gremlin-img';
          gimg.src = config.gremlin?.imageUrl || '';
          tile.appendChild(gimg);
          
          tile.dataset.optionId = optionIds[k];
        }
      }
    }

    // Game state
    let selectedOptionIds = new Set(); // options that have been selected
    let activeIdx = 0; // current active tile index
    let hopping = false;
    let hopTimer = null;
    let hopIntervalMs = 160;
    let gremlinIdx = -1; // current gremlin tile index
    let hopCount = 0;

    function setActive(idx) {
      tiles.forEach((t, i) => {
        if (t) t.classList.toggle("active", i === idx);
      });
    }

    function renderDisabled() {
      tiles.forEach((t) => {
        if (!t) return;
        const disabled = selectedOptionIds.has(t.dataset.optionId);
        t.classList.toggle("disabled", disabled);
      });
    }

    function selectOption(tileIdx) {
      const tile = tiles[tileIdx];
      if (!tile) return;
      const optId = tile.dataset.optionId;
      if (selectedOptionIds.has(optId)) return; // already selected
      
      selectedOptionIds.add(optId);
      tile.classList.add("selected");
      renderDisabled();
    }

    function placeGremlinRandom() {
      // Choose a tile index not currently disabled by selection
      const candidates = [];
      for (let i = 0; i < tiles.length; i++) {
        if (tiles[i] && !selectedOptionIds.has(tiles[i].dataset.optionId)) {
          candidates.push(i);
        }
      }
      if (candidates.length === 0) {
        gremlinIdx = -1;
        return;
      }
      gremlinIdx = candidates[Math.floor(Math.random() * candidates.length)];
      tiles.forEach((t, i) => {
        if (t) t.classList.toggle("gremlin", i === gremlinIdx);
      });
    }

    // Audio
    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    let muted = false;

    function ensureAudio() {
      try {
        if (audioCtx.state === "suspended") audioCtx.resume();
      } catch {}
    }

    function playBleep() {
      if (muted) return;
      try {
        ensureAudio();
        const o = audioCtx.createOscillator();
        const g = audioCtx.createGain();
        o.type = "square";
        o.frequency.value = 600 + Math.random() * 200;
        g.gain.value = 0.05;
        o.connect(g).connect(audioCtx.destination);
        o.start();
        o.stop(audioCtx.currentTime + 0.06);
      } catch {}
    }

    function playSelect() {
      if (muted) return;
      try {
        ensureAudio();
        const o = audioCtx.createOscillator();
        const g = audioCtx.createGain();
        o.type = "triangle";
        o.frequency.setValueAtTime(220, audioCtx.currentTime);
        o.frequency.linearRampToValueAtTime(880, audioCtx.currentTime + 0.25);
        g.gain.setValueAtTime(0.08, audioCtx.currentTime);
        g.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + 0.35);
        o.connect(g).connect(audioCtx.destination);
        o.start();
        o.stop(audioCtx.currentTime + 0.4);
      } catch {}
    }

    function playCackle() {
      if (muted) return;
      try {
        ensureAudio();
        const now = audioCtx.currentTime;
        for (let i = 0; i < 8; i++) {
          const start = now + i * 0.06;
          const o = audioCtx.createOscillator();
          const g = audioCtx.createGain();
          o.type = "square";
          const base = 380 + Math.random() * 320;
          o.frequency.setValueAtTime(base, start);
          o.frequency.exponentialRampToValueAtTime(base * 0.6, start + 0.05);
          g.gain.setValueAtTime(0.09, start);
          g.gain.exponentialRampToValueAtTime(0.0001, start + 0.08);
          o.connect(g).connect(audioCtx.destination);
          o.start(start);
          o.stop(start + 0.09);
        }
      } catch {}
    }

    function hopOnce() {
      // Move to next enabled tile clockwise
      let next = activeIdx;
      for (let step = 0; step < tiles.length; step++) {
        next = (next + 1) % tiles.length;
        const t = tiles[next];
        if (t && !selectedOptionIds.has(t.dataset.optionId)) {
          activeIdx = next;
          setActive(activeIdx);
          playBleep();
          break;
        }
      }
      // Move gremlin every 6th hop
      hopCount = (hopCount + 1) % 6;
      if (hopCount === 0) placeGremlinRandom();
    }

    function startHopping() {
      if (hopTimer) clearInterval(hopTimer);
      hopping = true;
      hopTimer = setInterval(() => {
        hopOnce();
      }, hopIntervalMs);
    }

    function stopHopping() {
      hopping = false;
      if (hopTimer) {
        clearInterval(hopTimer);
        hopTimer = null;
      }
    }

    function stopAndSelect() {
      if (!hopping) return;
      stopHopping();
      
      // Check if gremlin hit
      if (activeIdx === gremlinIdx) {
        // Gremlin hit! Pause but don't select
        playCackle();
        tiles.forEach(t => t.classList.remove("active"));
        return;
      }
      
      playSelect();
      selectOption(activeIdx);
      tiles.forEach(t => t.classList.remove("active"));
    }

    // Start overlay
    const startOverlay = document.getElementById("startOverlay");
    startOverlay.addEventListener("click", () => {
      ensureAudio();
      startOverlay.classList.add("hidden");
      startHopping();
    });

    // Initialize
    (async () => {
      await tryLoadDefaultFromConfigJson();
      config = loadConfig();
      centerImg.src = config.centerImageUrl || "";
      assignTitles();
      renderDisabled();
      setActive(activeIdx);
      placeGremlinRandom();
      // Don't auto-start; wait for user click
    })();
  </script>
</body>
</html>

