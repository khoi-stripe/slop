<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Press Your Luck-style Board</title>
  <meta name="theme-color" content="#c1121f" />
  <link rel="manifest" href="manifest.json" />
  <script>
    // Register service worker for installability (optional but helps PWA criteria)
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        navigator.serviceWorker.register('./sw.js', { scope: './' }).catch(() => {});
      });
    }
  </script>
  <style>
    :root {
      --bg: #0e1018;
      --panel: #141827;
      --tile: #1b2240;
      --tile-border: #2a3568;
      --tile-active: #fbbf24;
      --tile-active-glow: rgba(251,191,36,0.45);
      --tile-disabled: #0f1428;
      --tile-text: #e8ecf6;
      --muted: #9aa4bf;
      --accent: #7c5cff;
      --danger: #ef4444;
      --success: #31c48d;
      --selected-yellow: #E1B033;
      --gremlin-bg: rgba(0,0,0,0.1);
    }

    * { box-sizing: border-box; }
    html, body { height: 100%; }
    html { overflow: auto; }
    body {
      margin: 0;
      font-family: ui-sans-serif, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      background: #c1121f;
      color: var(--tile-text);
      display: grid;
      place-items: center;
      padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);
      overflow: auto;
    }

    .app {
      /* Fill as much viewport as possible without clipping, preserving 16:9 */
      width: min(100svw, calc(100svh * (16 / 9)));
      /* Let aspect-ratio compute exact height to avoid rounding mismatch */
      height: auto;
      aspect-ratio: 16 / 9; /* 16:9 stage */
      background: transparent;
      border: none;
      border-radius: 0;
      padding: clamp(8px, 1.5cqi, 20px);
      display: grid;
      grid-template-rows: auto 1fr auto;
      gap: clamp(6px, 1cqi, 16px);
      position: relative;
      box-shadow: none;
      /* Enable container relative units for proportional scaling */
      container-type: size;
      font-size: clamp(12px, 2.2cqi, 18px);
      overflow: visible;
    }

    .header, .footer {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      font-size: 14px;
      color: var(--muted);
    }
    .title { font-weight: 700; letter-spacing: 0.2px; color: var(--tile-text); }

    .board {
      position: relative;
      display: grid;
      grid-template-columns: repeat(6, 1fr);
      grid-template-rows: repeat(5, 1fr);
      gap: clamp(6px, 1cqi, 16px);
      padding: clamp(4px, 0.8cqi, 12px);
    }

    /* We'll place 18 perimeter tiles and one center area spanning 4 cells x 2 rows */
    .tile, .center {
      border-radius: 4px;
      display: grid;
      grid-auto-flow: row;
      place-items: center;
      text-align: center;
      padding: clamp(8px, 1.8cqi, 24px);
      overflow: hidden;
      position: relative;
      transition: box-shadow 120ms ease, transform 80ms ease, background 180ms ease, border-color 180ms ease;
    }

    /* Make tiles transparent with no stroke */
    .tile {
      background: rgba(0,0,0,0.1);
      border: none;
    }

    .tile .title { font-size: clamp(12px, 3cqi, 28px); font-weight: 700; color: var(--tile-text); }
    .tile .subtitle { font-size: clamp(10px, 2cqi, 16px); color: var(--muted); }

    /* Gremlin visuals */
    .tile .gremlin-img { display: none; width: 100%; height: 100%; object-fit: contain; border-radius: 4px; }
    .tile.gremlin .gremlin-img { display: block; }
    .tile.gremlin .title { display: none; }

    .tile.active {
      box-shadow: 0 0 0 3px var(--tile-active-glow), 0 0 24px 4px rgba(245,158,11,0.35);
      background: rgba(0,0,0,0.1);
      border: none;
    }

    .tile.disabled {
      background: rgba(0,0,0,0.1);
      border: none;
      filter: none;
      opacity: 0.2; /* dim duplicates of a selected option */
    }

    /* Selected tile emphasis (must remain readable with white text) */
    .tile.selected {
      background: var(--selected-yellow);
      border: none;
      color: #000000;
      opacity: 1; /* keep chosen tile fully visible */
    }
    .tile.selected .title { color: #000000; }

    /* image/reveal removed; tiles show title only */

    .center {
      grid-column: 2 / span 4; /* columns 2-5 */
      grid-row: 2 / span 3;    /* rows 2-4 */
      background: radial-gradient(600px 260px at 50% 40%, #1c2347, #12162a 70%);
      border: none;
      padding: 0;
      min-height: 0; /* allow grid to shrink without overflow */
    }
    .center img {
      width: 100%; height: 100%; object-fit: contain;
      max-height: 100%;
    }

    .kbd {
      background: rgba(255,255,255,0.06);
      border: 1px solid rgba(255,255,255,0.15);
      border-bottom-width: 2px;
      padding: 1px 6px; border-radius: 4px; color: #cbd5e1;
      font-size: 12px; font-weight: 600; letter-spacing: 0.2px;
    }

    .config-panel {
      position: absolute; inset: 16px; background: rgba(10,12,20,0.9);
      border: 1px solid #2a3568; border-radius: 4px; padding: 10px; display: none;
      grid-template-rows: auto 1fr auto; gap: 8px;
    }
    .config-panel textarea {
      width: 100%; height: 100%; resize: none; background: #0f1428; color: #e8ecf6; border: 1px solid #27315c; border-radius: 8px; padding: 8px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; font-size: 12px;
    }
    .config-panel .row { display: flex; justify-content: space-between; align-items: center; gap: 8px; }
    .btn { background: #1a2144; color: #e8ecf6; border: 1px solid #2a3568; padding: 6px 10px; border-radius: 4px; cursor: pointer; }
    .btn:hover { border-color: #3a4a86; }
  </style>
</head>
<body>
  <div class="app" id="app">
    <div class="header" id="uiHeader" style="display:none;">
      <div>
        <span>Space: <span class="kbd">stop/select</span></span>
        <span style="margin-left:10px;">R: <span class="kbd">reset</span></span>
        <span style="margin-left:10px;">E: <span class="kbd">edit config</span></span>
        <button class="btn" id="muteBtn" style="margin-left:10px;">Sound: On</button>
      </div>
    </div>

    <div class="board" id="board">
      <!-- 6x6 grid; we render tiles around the perimeter, center is a 4x3 area -->
      <!-- Tiles will be injected by JS following perimeter order clockwise starting top-left -->
      <div class="center" id="center">
        <img id="centerImage" alt="Center" />
      </div>
    </div>

    

    <div class="config-panel" id="configPanel">
      <div class="row">
        <div class="title">Configuration (JSON)</div>
        <div>
          <button class="btn" id="configClose">Close (Esc)</button>
          <button class="btn" id="configReset">Reset to Defaults</button>
          <button class="btn" id="configSave">Save</button>
        </div>
      </div>
      <textarea id="configText"></textarea>
      <div class="row"><div style="font-size:12px; color: var(--muted);">Changes persist in your browser</div></div>
    </div>
  </div>

  <script>
    // Configuration schema stored in localStorage
    let DEFAULT_CONFIG = {
      centerImageUrl: "https://upload.wikimedia.org/wikipedia/commons/thumb/5/5f/Emoji_u1f389.svg/512px-Emoji_u1f389.svg.png",
      gremlin: { title: "AI Gremlin", imageUrl: "" },
      options: [
        { id: "A", title: "Option A" },
        { id: "B", title: "Option B" },
        { id: "C", title: "Option C" },
        { id: "D", title: "Option D" },
        { id: "E", title: "Option E" },
        { id: "F", title: "Option F" }
      ]
    };

    async function tryLoadDefaultFromConfigJson() {
      try {
        const res = await fetch('./config.json', { cache: 'no-store' });
        if (!res.ok) return;
        const json = await res.json();
        if (!json || !Array.isArray(json.options) || json.options.length !== 6) return;
        DEFAULT_CONFIG = json;
      } catch {}
    }

    const STORAGE_KEY = "pyl_config_v1";
    const STORAGE_STATE_KEY = "pyl_state_v1";

    function loadConfig() {
      try {
        const raw = localStorage.getItem(STORAGE_KEY);
        if (!raw) return structuredClone(DEFAULT_CONFIG);
        const cfg = JSON.parse(raw);
        // Basic validation
        if (!cfg.options || cfg.options.length !== 6) return structuredClone(DEFAULT_CONFIG);
        return cfg;
      } catch (e) {
        return structuredClone(DEFAULT_CONFIG);
      }
    }
    function saveConfig(cfg) {
      localStorage.setItem(STORAGE_KEY, JSON.stringify(cfg));
    }

    function loadState() {
      try {
        const raw = localStorage.getItem(STORAGE_STATE_KEY);
        if (!raw) return null;
        return JSON.parse(raw);
      } catch (e) { return null; }
    }
    function saveState(state) {
      localStorage.setItem(STORAGE_STATE_KEY, JSON.stringify(state));
    }

    const boardEl = document.getElementById("board");
    const statusEl = document.getElementById("status");
    const centerImg = document.getElementById("centerImage");
    const headerEl = document.getElementById("uiHeader");

    let config;

    // Build perimeter positions in 6x5 logical grid (5 rows). We'll use 18 tiles: 6 top, 3 right, 6 bottom, 3 left.
    // Rows: 1..5, Cols: 1..6. Center spans rows 2..4 and cols 2..5.
    const ring = [];
    for (let c = 1; c <= 6; c++) ring.push([1, c]);        // top 6
    for (let r = 2; r <= 4; r++) ring.push([r, 6]);         // right 3 (rows 2-4)
    for (let c = 6; c >= 1; c--) ring.push([5, c]);         // bottom 6 (row 5)
    for (let r = 4; r >= 2; r--) ring.push([r, 1]);         // left 3 (rows 4-2)
    // ring length should be 18

    // Create tiles
    const tiles = [];
    ring.forEach(([r, c], idx) => {
      const tile = document.createElement("div");
      tile.className = "tile";
      tile.style.gridRow = r;
      tile.style.gridColumn = c;

      const title = document.createElement("div");
      title.className = "title";
      tile.appendChild(title);

      boardEl.appendChild(tile);
      // gremlin image holder
      const gimg = document.createElement("img");
      gimg.className = "gremlin-img";
      tile.appendChild(gimg);

      tiles.push({ el: tile, title, gimg, assignedOptionId: null });
    });

    // Assign 6 options to 18 tiles -> 3 tiles per option. We'll shuffle ring indices and distribute evenly.
    function shuffle(arr) { const a = arr.slice(); for (let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]];} return a; }

    function assignOptions() {
      const idxs = shuffle(Array.from({length: tiles.length}, (_, i) => i));
      const optionIds = config.options.map(o => o.id);
      // 3 slots per option
      for (let k = 0; k < optionIds.length; k++) {
        for (let rep = 0; rep < 3; rep++) {
          const tileIdx = idxs[k*3 + rep];
          tiles[tileIdx].assignedOptionId = optionIds[k];
        }
      }
      // Place gremlin at a random tile not reserved for options? We overlay; gremlin is independent and can sit on any enabled tile during hopping.
      // Set titles and gremlin image src
      // Set titlecards
      const byId = Object.fromEntries(config.options.map(o => [o.id, o]));
      tiles.forEach(t => {
        const opt = byId[t.assignedOptionId];
        t.title.textContent = opt.title;
        t.gimg.src = config.gremlin?.imageUrl || "";
        t.el.classList.remove("gremlin");
      });
    }

    // State
    let selectedOptionIds = new Set(); // once an option is selected, all its tiles are disabled
    let activeIdx = 0;
    let hopping = true;
    let hopTimer = null;
    let hopIntervalMs = 160; // base; we can add jitter
    let gremlinIdx = -1; // current gremlin tile index
    let hopCount = 0;

    function placeGremlinRandom() {
      // choose a tile index not currently disabled by selection
      const candidates = [];
      for (let i = 0; i < tiles.length; i++) {
        if (!selectedOptionIds.has(tiles[i].assignedOptionId)) candidates.push(i);
      }
      if (candidates.length === 0) { gremlinIdx = -1; return; }
      gremlinIdx = candidates[Math.floor(Math.random() * candidates.length)];
      tiles.forEach((t, i) => t.el.classList.toggle("gremlin", i === gremlinIdx));
    }

    function renderDisabled() {
      tiles.forEach((t) => {
        const disabled = selectedOptionIds.has(t.assignedOptionId);
        t.el.classList.toggle("disabled", disabled);
      });
    }

    function setActive(idx) {
      tiles.forEach((t, i) => t.el.classList.toggle("active", i === idx));
    }

    function hopOnce() {
      // Move to next enabled tile clockwise
      let next = activeIdx;
      for (let step = 0; step < tiles.length; step++) {
        next = (next + 1) % tiles.length;
        const t = tiles[next];
        if (!selectedOptionIds.has(t.assignedOptionId)) {
          activeIdx = next;
          setActive(activeIdx);
          playBleep();
          break;
        }
      }
      // Move gremlin every 6th hop
      hopCount = (hopCount + 1) % 6;
      if (hopCount === 0) placeGremlinRandom();
    }

    function startHopping() {
      if (hopTimer) clearInterval(hopTimer);
      hopping = true;
      hopTimer = setInterval(() => {
        hopOnce();
      }, hopIntervalMs);
    }

    function stopAndSelect() {
      if (!hopping) return;
      hopping = false;
      if (hopTimer) { clearInterval(hopTimer); hopTimer = null; }
      const t = tiles[activeIdx];
      // If gremlin is on the active tile, gremlin hit
      if (activeIdx === gremlinIdx) {
        playCackle();
        // Pause board; do not remove any option from play. Keep gremlin moving only when we resume.
        tiles.forEach(tt => tt.el.classList.remove("active"));
        return;
      }
      // Select this tile's option; if already selected, find next available forward
      let chosen = t;
      if (selectedOptionIds.has(t.assignedOptionId)) {
        for (let step = 0; step < tiles.length; step++) {
          const idx = (activeIdx + step) % tiles.length;
          if (!selectedOptionIds.has(tiles[idx].assignedOptionId)) { chosen = tiles[idx]; activeIdx = idx; break; }
        }
      }
      const optId = chosen.assignedOptionId;
      selectedOptionIds.add(optId);
      // Mark the chosen tile as selected (yellow), and disable all tiles for this option.
      chosen.el.classList.add("selected");
      playSelect();
      renderDisabled();
      updateStatus();
      // Persist selection state
      try { localStorage.setItem(STORAGE_STATE_KEY, JSON.stringify({ selectedOptionIds: Array.from(selectedOptionIds) })); } catch {}
      // Always pause after selection: remove active highlight
      tiles.forEach(tt => tt.el.classList.remove("active"));
    }

    function updateStatus() {
      if (!statusEl) return;
      const remaining = 6 - selectedOptionIds.size;
      statusEl.textContent = remaining > 0 ? `${remaining} remaining` : `All done — press R to reset`;
    }

    function resetAll(keepConfig = true) {
      if (hopTimer) { clearInterval(hopTimer); hopTimer = null; }
      hopping = true;
      selectedOptionIds = new Set();
      tiles.forEach(t => { t.el.classList.remove("disabled", "selected", "active"); });
      assignOptions();
      renderDisabled();
      activeIdx = 0;
      setActive(activeIdx);
      placeGremlinRandom();
      hopCount = 0;
      startHopping();
      updateStatus();
      saveState({ selectedOptionIds: Array.from(selectedOptionIds), seed: null });
    }

    // Audio (WebAudio simple bleeps)
    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    const MUTE_STORAGE_KEY = "pyl_muted_v1";
    function loadMuted() { try { return localStorage.getItem(MUTE_STORAGE_KEY) === "1"; } catch { return false; } }
    function saveMuted(m) { try { localStorage.setItem(MUTE_STORAGE_KEY, m ? "1" : "0"); } catch {} }
    let muted = loadMuted();
    function ensureAudio() { try { if (audioCtx.state === "suspended") audioCtx.resume(); } catch {} }
    function playBleep() {
      if (muted) return;
      try {
        ensureAudio();
        const o = audioCtx.createOscillator();
        const g = audioCtx.createGain();
        o.type = "square";
        o.frequency.value = 600 + Math.random()*200; // random bleeps
        g.gain.value = 0.05;
        o.connect(g).connect(audioCtx.destination);
        o.start();
        o.stop(audioCtx.currentTime + 0.06);
      } catch {}
    }
    function playSelect() {
      if (muted) return;
      try {
        ensureAudio();
        const o = audioCtx.createOscillator();
        const g = audioCtx.createGain();
        o.type = "triangle";
        o.frequency.setValueAtTime(220, audioCtx.currentTime);
        o.frequency.linearRampToValueAtTime(880, audioCtx.currentTime + 0.25);
        g.gain.setValueAtTime(0.08, audioCtx.currentTime);
        g.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + 0.35);
        o.connect(g).connect(audioCtx.destination);
        o.start(); o.stop(audioCtx.currentTime + 0.4);
      } catch {}
    }

    function playCackle() {
      if (muted) return;
      try {
        ensureAudio();
        const now = audioCtx.currentTime;
        // series of short jittery bursts to resemble a cackle
        for (let i = 0; i < 8; i++) {
          const start = now + i * 0.06;
          const o = audioCtx.createOscillator();
          const g = audioCtx.createGain();
          o.type = "square";
          const base = 380 + Math.random() * 320;
          o.frequency.setValueAtTime(base, start);
          o.frequency.exponentialRampToValueAtTime(base * 0.6, start + 0.05);
          g.gain.setValueAtTime(0.09, start);
          g.gain.exponentialRampToValueAtTime(0.0001, start + 0.08);
          o.connect(g).connect(audioCtx.destination);
          o.start(start);
          o.stop(start + 0.09);
        }
      } catch {}
    }

    // Mute toggle UI
    const muteBtn = document.getElementById("muteBtn");
    function updateMuteUi() { muteBtn.textContent = muted ? "Sound: Off" : "Sound: On"; }
    function toggleMute() { muted = !muted; saveMuted(muted); updateMuteUi(); ensureAudio(); }
    muteBtn.addEventListener("click", toggleMute);
    updateMuteUi();

    // Config editor
    const panel = document.getElementById("configPanel");
    const configText = document.getElementById("configText");
    document.getElementById("configClose").addEventListener("click", () => hideConfig());
    document.getElementById("configReset").addEventListener("click", () => { config = structuredClone(DEFAULT_CONFIG); centerImg.src = config.centerImageUrl; saveConfig(config); loadConfigIntoEditor(); assignOptions(); });
    document.getElementById("configSave").addEventListener("click", () => {
      try {
        const next = JSON.parse(configText.value);
        if (!next.options || next.options.length !== 6) { alert("Config must contain exactly 6 options."); return; }
        config = next; saveConfig(config); centerImg.src = config.centerImageUrl || ""; assignOptions();
        hideConfig();
      } catch (e) { alert("Invalid JSON"); }
    });
    function showConfig() { panel.style.display = "grid"; loadConfigIntoEditor(); }
    function hideConfig() { panel.style.display = "none"; }
    function loadConfigIntoEditor() { configText.value = JSON.stringify(config, null, 2); }

    function toggleMenuHeader() {
      if (!headerEl) return;
      headerEl.style.display = (headerEl.style.display === "none" || headerEl.style.display === "") ? "flex" : "none";
    }

    // Keyboard controls: Space toggles (stop/select when hopping, resume when paused), R to reset, E to edit config, H to toggle menu
    window.addEventListener("keydown", (e) => {
      if (panel.style.display === "grid") {
        if (e.key === "Escape") { hideConfig(); }
        return;
      }
      if (e.key === " ") {
        e.preventDefault();
        if (selectedOptionIds.size >= 6) return; // finished
        if (hopping) {
          stopAndSelect();
        } else {
          startHopping();
        }
      }
      else if (e.key.toLowerCase() === "r") { e.preventDefault(); resetAll(); }
      else if (e.key.toLowerCase() === "e") { e.preventDefault(); showConfig(); }
      else if (e.key.toLowerCase() === "m" || e.key.toLowerCase() === "s") { e.preventDefault(); toggleMute(); }
      else if (e.key.toLowerCase() === "h") { e.preventDefault(); toggleMenuHeader(); }
    });

    // Initialize after attempting to load config.json
    (async () => {
      await tryLoadDefaultFromConfigJson();
      config = loadConfig();
      centerImg.src = config.centerImageUrl || "";
      assignOptions();
      renderDisabled();
      setActive(activeIdx);
      placeGremlinRandom();
      hopCount = 0;
      startHopping();
      updateStatus();
    })();
  </script>
</body>
</html>


