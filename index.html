<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Slop Karaoke</title>
  <style>
    * { box-sizing: border-box; }
    html, body { height: 100%; margin: 0; overflow: hidden; }
    body {
      font-family: ui-sans-serif, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      background: #c1121f;
      color: #e8ecf6;
    }

    .app {
      width: 100vw;
      height: 100vh;
      padding: clamp(8px, 1.5cqi, 24px);
      display: grid;
      place-items: center;
      /* Enable container queries */
      container-type: size;
    }

    .board {
      display: grid;
      grid-template-columns: repeat(6, 1fr);
      grid-template-rows: repeat(5, 1fr);
      gap: clamp(6px, 1cqi, 16px);
      padding: clamp(4px, 0.6cqi, 12px);
      /* Fit within container, maintaining 16:9 */
      max-height: 100%;
      max-width: 100%;
      width: min(100%, calc(100cqh * (16 / 9)));
      height: min(100%, calc(100cqw * (9 / 16)));
      aspect-ratio: 16 / 9;
      position: relative; /* for config panel positioning */
      border-radius: 12px;
    }

    @keyframes flashingLights {
      0%, 100% {
        border-color: #FFD700;
        box-shadow: 0 0 20px #FFD700, 0 0 40px #FFD700;
      }
      50% {
        border-color: #FFFFFF;
        box-shadow: 0 0 20px #FFFFFF, 0 0 40px #FFFFFF;
      }
    }

    /* Marquee lights */
    .board-lights {
      position: absolute;
      inset: -20px; /* Extend outside board to create spacing */
      pointer-events: none;
      z-index: 1000;
    }

    .board-light {
      position: absolute;
      width: clamp(16px, 2cqi, 24px);
      height: clamp(16px, 2cqi, 24px);
      border-radius: 50%;
      background: #FFD700;
      box-shadow: 0 0 15px #FFD700,
                  0 0 30px #FFD700,
                  0 0 45px rgba(255,215,0,0.8);
      animation: boardLightPulse 0.3s infinite;
      transform: translate(-50%, -50%);
    }

    @keyframes boardLightPulse {
      0%, 100% {
        opacity: 0.3;
        transform: translate(-50%, -50%) scale(0.8);
        box-shadow: 0 0 5px rgba(255,215,0,0.3);
      }
      50% {
        opacity: 1;
        transform: translate(-50%, -50%) scale(1);
        box-shadow: 0 0 15px #FFD700,
                    0 0 30px #FFD700,
                    0 0 45px rgba(255,215,0,0.8);
      }
    }

    @keyframes flashingOutline {
      0%, 100% {
        outline-color: #FFD700;
        box-shadow: 0 0 20px #FFD700, 0 0 40px #FFD700;
      }
      50% {
        outline-color: #FFFFFF;
        box-shadow: 0 0 20px #FFFFFF, 0 0 40px #FFFFFF;
      }
    }

    .tile {
      background: rgba(0,0,0,0.1);
      border: none;
      border-radius: 8px;
      display: grid;
      place-items: center;
      text-align: center;
      padding: clamp(8px, 1.5cqi, 24px);
      font-size: clamp(14px, 1.25cqi, 40px);
      font-weight: 700;
      line-height: 1.2;
      transition: box-shadow 120ms ease, transform 80ms ease, background 180ms ease, opacity 180ms ease;
      position: relative; /* needed for absolute positioned gremlin */
    }

    .tile.active {
      box-shadow: 0 0 0 3px rgba(251,191,36,0.45), 0 0 24px 4px rgba(245,158,11,0.35);
      outline: 4px solid #F59E34;
      outline-offset: 0px;
    }

    .tile.selected {
      /* Matches unselected tile style - no special styling */
    }

    .tile.just-selected {
      background: #E1B033;
      color: #000000;
      outline: 4px solid;
      outline-offset: 0px;
      animation: flashingOutline 0.8s infinite;
    }

    .tile.disabled {
      opacity: 0.2;
    }

    .tile.disabled.selected {
      opacity: 1; /* selected tile stays fully visible */
    }

    /* Gremlin overlay */
    .tile .gremlin-img {
      display: none;
      position: absolute;
      inset: 0; /* fill entire tile */
      width: 100%;
      height: 100%;
      object-fit: cover;
      border-radius: 8px;
      z-index: 10;
    }

    .tile.gremlin .gremlin-img {
      display: block;
    }

    .tile.gremlin .tile-text {
      display: none;
    }

    .center {
      grid-column: 2 / span 4;
      grid-row: 2 / span 3;
      background: radial-gradient(circle, #1c2347, #12162a);
      border: none;
      border-radius: 8px;
      padding: 0;
      overflow: hidden;
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
    }
    
    .center img,
    .center video {
      width: 100%;
      height: 100%;
      object-fit: cover;
      position: absolute;
      inset: 0;
    }

    .center video {
      transform: scaleX(-1); /* Mirror effect for camera */
    }

    .center img.hidden,
    .center video.hidden {
      display: none;
    }

    /* Start overlay */
    #startOverlay {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.9);
      display: grid;
      place-items: center;
      z-index: 1000;
      cursor: pointer;
    }

    #startOverlay .message {
      font-size: 32px;
      font-weight: 700;
      color: #E1B033;
      text-align: center;
      padding: 32px;
    }

    #startOverlay.hidden {
      display: none;
    }

    /* UI Elements */
    .header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      font-size: clamp(10px, 1.2cqi, 16px);
      color: rgba(255,255,255,0.7);
    }

    .kbd {
      background: rgba(255,255,255,0.06);
      border: 1px solid rgba(255,255,255,0.15);
      border-bottom-width: 2px;
      padding: 1px 6px;
      border-radius: 8px;
      color: #cbd5e1;
      font-size: clamp(10px, 1cqi, 14px);
      font-weight: 600;
    }

    .btn {
      background: #1a2144;
      color: #e8ecf6;
      border: 1px solid #2a3568;
      padding: 4px 8px;
      border-radius: 8px;
      cursor: pointer;
      font-size: clamp(10px, 1cqi, 14px);
    }

    .btn:hover {
      border-color: #3a4a86;
    }

    /* Config panel */
    .config-panel {
      position: absolute;
      inset: 16px;
      background: rgba(10,12,20,0.95);
      border: 1px solid #2a3568;
      border-radius: 8px;
      padding: 16px;
      display: none;
      grid-template-rows: auto 1fr auto;
      gap: 12px;
      z-index: 100;
    }

    .config-panel.visible {
      display: grid;
    }

    .config-panel textarea {
      width: 100%;
      height: 100%;
      resize: none;
      background: #0f1428;
      color: #e8ecf6;
      border: 1px solid #27315c;
      border-radius: 8px;
      padding: 12px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      font-size: 12px;
    }

    .config-panel .row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 8px;
    }

    .config-panel .title {
      font-weight: 700;
      font-size: 16px;
    }
  </style>
</head>
<body>
  <div id="startOverlay">
    <div class="message">Click to Start</div>
  </div>
  <div class="app">
    <div class="header" id="uiHeader" style="display:none;">
      <div>
        <span>Space: <span class="kbd">stop/select</span></span>
        <span style="margin-left:10px;">R: <span class="kbd">reset</span></span>
        <span style="margin-left:10px;">E: <span class="kbd">edit config</span></span>
        <span style="margin-left:10px;">C: <span class="kbd">toggle camera</span></span>
        <button class="btn" id="muteBtn" style="margin-left:10px;">Sound: On</button>
        <button class="btn" id="cameraBtn" style="margin-left:10px;">Camera: Off</button>
      </div>
    </div>

    <div class="board" id="board">
      <!-- Marquee lights container -->
      <div class="board-lights" id="boardLights"></div>
      
      <!-- Perimeter tiles -->
      <div class="tile" style="grid-column: 1; grid-row: 1;">1</div>
      <div class="tile" style="grid-column: 2; grid-row: 1;">2</div>
      <div class="tile" style="grid-column: 3; grid-row: 1;">3</div>
      <div class="tile" style="grid-column: 4; grid-row: 1;">4</div>
      <div class="tile" style="grid-column: 5; grid-row: 1;">5</div>
      <div class="tile" style="grid-column: 6; grid-row: 1;">6</div>
      
      <div class="tile" style="grid-column: 6; grid-row: 2;">7</div>
      <div class="tile" style="grid-column: 6; grid-row: 3;">8</div>
      <div class="tile" style="grid-column: 6; grid-row: 4;">9</div>
      
      <div class="tile" style="grid-column: 6; grid-row: 5;">10</div>
      <div class="tile" style="grid-column: 5; grid-row: 5;">11</div>
      <div class="tile" style="grid-column: 4; grid-row: 5;">12</div>
      <div class="tile" style="grid-column: 3; grid-row: 5;">13</div>
      <div class="tile" style="grid-column: 2; grid-row: 5;">14</div>
      <div class="tile" style="grid-column: 1; grid-row: 5;">15</div>
      
      <div class="tile" style="grid-column: 1; grid-row: 4;">16</div>
      <div class="tile" style="grid-column: 1; grid-row: 3;">17</div>
      <div class="tile" style="grid-column: 1; grid-row: 2;">18</div>
      
      <!-- Center tile -->
      <div class="center" id="center">
        <img id="centerImage" alt="Center" />
        <video id="centerVideo" class="hidden" autoplay playsinline muted></video>
      </div>

      <!-- Config panel -->
      <div class="config-panel" id="configPanel">
        <div class="row">
          <div class="title">Configuration (JSON)</div>
          <div>
            <button class="btn" id="configClose">Close (Esc)</button>
            <button class="btn" id="configReset">Reset to Defaults</button>
            <button class="btn" id="configSave">Save</button>
          </div>
        </div>
        <textarea id="configText"></textarea>
        <div class="row">
          <div style="font-size:12px; color: rgba(255,255,255,0.5);">Changes persist in your browser</div>
        </div>
      </div>
    </div>
  </div>

  <script>
    // Configuration system
    let DEFAULT_CONFIG = {
      centerImageUrl: "images/gremlin_center.png",
      gremlin: { title: "AI Gremlin", imageUrl: "images/gremlin.png", cackleAudioUrl: "" },
      randomizeTilesEveryNHops: 10, // Set to 0 to disable tile randomization
      options: [
        { id: "A", title: "Option A" },
        { id: "B", title: "Option B" },
        { id: "C", title: "Option C" },
        { id: "D", title: "Option D" },
        { id: "E", title: "Option E" },
        { id: "F", title: "Option F" }
      ]
    };

    const STORAGE_KEY = "pyl_config_v2";

    async function tryLoadDefaultFromConfigJson() {
      try {
        const res = await fetch('./config.json', { cache: 'no-store' });
        if (!res.ok) return;
        const json = await res.json();
        if (!json || !Array.isArray(json.options) || json.options.length !== 6) return;
        DEFAULT_CONFIG = json;
      } catch {}
    }

    function loadConfig() {
      try {
        const raw = localStorage.getItem(STORAGE_KEY);
        if (!raw) return structuredClone(DEFAULT_CONFIG);
        const cfg = JSON.parse(raw);
        if (!cfg.options || cfg.options.length !== 6) return structuredClone(DEFAULT_CONFIG);
        return cfg;
      } catch (e) {
        return structuredClone(DEFAULT_CONFIG);
      }
    }

    let config;
    const centerImg = document.getElementById("centerImage");
    const centerVideo = document.getElementById("centerVideo");

    // Camera functionality
    let cameraActive = false;
    let cameraStream = null;

    async function startCamera() {
      try {
        const stream = await navigator.mediaDevices.getUserMedia({ 
          video: { 
            facingMode: 'user',
            width: { ideal: 1280 },
            height: { ideal: 720 }
          } 
        });
        cameraStream = stream;
        centerVideo.srcObject = stream;
        cameraActive = true;
        centerImg.classList.add('hidden');
        centerVideo.classList.remove('hidden');
        updateCameraUI();
      } catch (err) {
        console.error('Camera access denied or unavailable:', err);
        alert('Camera access denied or unavailable. Make sure you\'re using HTTPS or localhost.');
        cameraActive = false;
        updateCameraUI();
      }
    }

    function stopCamera() {
      if (cameraStream) {
        cameraStream.getTracks().forEach(track => track.stop());
        cameraStream = null;
      }
      centerVideo.srcObject = null;
      cameraActive = false;
      centerVideo.classList.add('hidden');
      centerImg.classList.remove('hidden');
      updateCameraUI();
    }

    function toggleCamera() {
      if (cameraActive) {
        stopCamera();
      } else {
        startCamera();
      }
    }

    function updateCameraUI() {
      const cameraBtn = document.getElementById("cameraBtn");
      if (cameraBtn) {
        cameraBtn.textContent = cameraActive ? "Camera: On" : "Camera: Off";
      }
    }

    // Get all perimeter tiles (numbered 1-18)
    const tiles = Array.from(document.querySelectorAll('.tile')).filter(t => !t.classList.contains('center'));
    
    // Get board element for marquee control
    const board = document.getElementById("board");

    function assignTitles() {
      // Assign 6 options to 18 tiles (3 tiles per option)
      const optionIds = config.options.map(o => o.id);
      const indices = Array.from({length: 18}, (_, i) => i);
      // Shuffle
      for (let i = indices.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [indices[i], indices[j]] = [indices[j], indices[i]];
      }
      
      const byId = Object.fromEntries(config.options.map(o => [o.id, o]));
      
      for (let k = 0; k < optionIds.length; k++) {
        for (let rep = 0; rep < 3; rep++) {
          const tileIdx = indices[k * 3 + rep];
          const tile = tiles[tileIdx];
          const opt = byId[optionIds[k]];
          
          // Wrap text in span for gremlin hiding
          const textSpan = document.createElement('span');
          textSpan.className = 'tile-text';
          textSpan.textContent = opt.title;
          tile.textContent = '';
          tile.appendChild(textSpan);
          
          // Add gremlin image holder
          const gimg = document.createElement('img');
          gimg.className = 'gremlin-img';
          gimg.src = config.gremlin?.imageUrl || '';
          tile.appendChild(gimg);
          
          tile.dataset.optionId = optionIds[k];
        }
      }
    }

    function randomizeTiles() {
      // Randomize the assignment of options to tiles while preserving selection state
      // Only randomize tiles that haven't been selected yet
      const unselectedTiles = [];
      const unselectedOptionIds = [];
      
      // Collect unselected tiles and their option IDs
      tiles.forEach((tile) => {
        if (!tile || selectedOptionIds.has(tile.dataset.optionId)) return;
        const optId = tile.dataset.optionId;
        if (!unselectedOptionIds.includes(optId)) {
          unselectedOptionIds.push(optId);
        }
        unselectedTiles.push(tile);
      });
      
      if (unselectedTiles.length === 0) return;
      
      // Shuffle the tiles array
      for (let i = unselectedTiles.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [unselectedTiles[i], unselectedTiles[j]] = [unselectedTiles[j], unselectedTiles[i]];
      }
      
      const byId = Object.fromEntries(config.options.map(o => [o.id, o]));
      const tilesPerOption = Math.floor(unselectedTiles.length / unselectedOptionIds.length);
      
      // Reassign options to shuffled tiles
      let tileIdx = 0;
      for (const optId of unselectedOptionIds) {
        const opt = byId[optId];
        const count = tilesPerOption + (tileIdx < unselectedTiles.length % unselectedOptionIds.length ? 1 : 0);
        
        for (let i = 0; i < count && tileIdx < unselectedTiles.length; i++, tileIdx++) {
          const tile = unselectedTiles[tileIdx];
          
          // Preserve gremlin and active states
          const wasGremlin = tile.classList.contains('gremlin');
          const wasActive = tile.classList.contains('active');
          
          // Update tile content
          const textSpan = tile.querySelector('.tile-text');
          if (textSpan) {
            textSpan.textContent = opt.title;
          }
          tile.dataset.optionId = optId;
          
          // Restore states
          if (wasGremlin) {
            tile.classList.add('gremlin');
          }
          if (wasActive) {
            tile.classList.add('active');
          }
        }
      }
    }

    // Game state
    let selectedOptionIds = new Set(); // options that have been selected
    let activeIdx = 0; // current active tile index
    let hopping = false;
    let hopTimer = null;
    let hopIntervalMs = 160;
    let gremlinIdx = -1; // current gremlin tile index
    let hopCount = 0;

    function setActive(idx) {
      tiles.forEach((t, i) => {
        if (t) t.classList.toggle("active", i === idx);
      });
    }

    function renderDisabled() {
      tiles.forEach((t) => {
        if (!t) return;
        const disabled = selectedOptionIds.has(t.dataset.optionId);
        t.classList.toggle("disabled", disabled);
      });
    }

    function selectOption(tileIdx) {
      const tile = tiles[tileIdx];
      if (!tile) return;
      const optId = tile.dataset.optionId;
      if (selectedOptionIds.has(optId)) return; // already selected
      
      selectedOptionIds.add(optId);
      tile.classList.add("selected", "just-selected");
      renderDisabled();
      
      // Pause board marquee animation
      if (board) board.style.animationPlayState = "paused";
      
      // Dim ALL tiles to 20% first (including previously selected)
      tiles.forEach(t => {
        if (t) {
          t.style.opacity = "0.2";
        }
      });
      
      // Then brighten only the tile just selected
      tile.style.opacity = "1";
    }

    function placeGremlinRandom() {
      // Choose a tile index not currently disabled by selection
      const candidates = [];
      for (let i = 0; i < tiles.length; i++) {
        if (tiles[i] && !selectedOptionIds.has(tiles[i].dataset.optionId)) {
          candidates.push(i);
        }
      }
      if (candidates.length === 0) {
        gremlinIdx = -1;
        return;
      }
      gremlinIdx = candidates[Math.floor(Math.random() * candidates.length)];
      tiles.forEach((t, i) => {
        if (t) t.classList.toggle("gremlin", i === gremlinIdx);
      });
    }

    // Audio
    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    let muted = false;
    let cackleAudioBuffer = null;

    function ensureAudio() {
      try {
        if (audioCtx.state === "suspended") audioCtx.resume();
      } catch {}
    }

    async function loadCackleAudio(url) {
      if (!url) {
        cackleAudioBuffer = null;
        return;
      }
      try {
        ensureAudio();
        const response = await fetch(url);
        const arrayBuffer = await response.arrayBuffer();
        cackleAudioBuffer = await audioCtx.decodeAudioData(arrayBuffer);
      } catch (e) {
        console.error("Failed to load cackle audio:", e);
        cackleAudioBuffer = null;
      }
    }

    function playBleep() {
      if (muted) return;
      try {
        ensureAudio();
        const o = audioCtx.createOscillator();
        const g = audioCtx.createGain();
        o.type = "square";
        o.frequency.value = 600 + Math.random() * 200;
        g.gain.value = 0.05;
        o.connect(g).connect(audioCtx.destination);
        o.start();
        o.stop(audioCtx.currentTime + 0.06);
      } catch {}
    }

    function playSelect() {
      if (muted) return;
      try {
        ensureAudio();
        const now = audioCtx.currentTime;
        
        // Main celebratory tone - louder and brighter
        const o1 = audioCtx.createOscillator();
        const g1 = audioCtx.createGain();
        o1.type = "sine";
        o1.frequency.setValueAtTime(523, now); // C5
        o1.frequency.linearRampToValueAtTime(1047, now + 0.15); // C6
        g1.gain.setValueAtTime(0.15, now);
        g1.gain.exponentialRampToValueAtTime(0.0001, now + 0.4);
        o1.connect(g1).connect(audioCtx.destination);
        o1.start(now);
        o1.stop(now + 0.45);
        
        // Harmony tone
        const o2 = audioCtx.createOscillator();
        const g2 = audioCtx.createGain();
        o2.type = "sine";
        o2.frequency.setValueAtTime(659, now); // E5
        o2.frequency.linearRampToValueAtTime(1319, now + 0.15); // E6
        g2.gain.setValueAtTime(0.1, now);
        g2.gain.exponentialRampToValueAtTime(0.0001, now + 0.4);
        o2.connect(g2).connect(audioCtx.destination);
        o2.start(now);
        o2.stop(now + 0.45);
        
        // Sparkle effect
        const o3 = audioCtx.createOscillator();
        const g3 = audioCtx.createGain();
        o3.type = "sine";
        o3.frequency.setValueAtTime(2093, now + 0.1); // C7
        g3.gain.setValueAtTime(0.08, now + 0.1);
        g3.gain.exponentialRampToValueAtTime(0.0001, now + 0.35);
        o3.connect(g3).connect(audioCtx.destination);
        o3.start(now + 0.1);
        o3.stop(now + 0.4);
      } catch {}
    }

    function playCackle() {
      if (muted) return;
      try {
        ensureAudio();
        
        // If we have a loaded audio file, play it
        if (cackleAudioBuffer) {
          const source = audioCtx.createBufferSource();
          source.buffer = cackleAudioBuffer;
          const gain = audioCtx.createGain();
          gain.gain.value = 1.0;
          source.connect(gain).connect(audioCtx.destination);
          source.start();
          return;
        }
        
        // Otherwise, fall back to synthetic cackle
        const now = audioCtx.currentTime;
        for (let i = 0; i < 8; i++) {
          const start = now + i * 0.06;
          const o = audioCtx.createOscillator();
          const g = audioCtx.createGain();
          o.type = "square";
          const base = 380 + Math.random() * 320;
          o.frequency.setValueAtTime(base, start);
          o.frequency.exponentialRampToValueAtTime(base * 0.6, start + 0.05);
          g.gain.setValueAtTime(0.09, start);
          g.gain.exponentialRampToValueAtTime(0.0001, start + 0.08);
          o.connect(g).connect(audioCtx.destination);
          o.start(start);
          o.stop(start + 0.09);
        }
      } catch {}
    }

    function hopOnce() {
      // Move to next enabled tile clockwise
      let next = activeIdx;
      for (let step = 0; step < tiles.length; step++) {
        next = (next + 1) % tiles.length;
        const t = tiles[next];
        if (t && !selectedOptionIds.has(t.dataset.optionId)) {
          activeIdx = next;
          setActive(activeIdx);
          playBleep();
          break;
        }
      }
      
      hopCount++;
      
      // Move gremlin every 6th hop
      if (hopCount % 6 === 0) {
        placeGremlinRandom();
      }
      
      // Randomize tiles every N hops if configured
      const randomizeInterval = config.randomizeTilesEveryNHops || 0;
      if (randomizeInterval > 0 && hopCount % randomizeInterval === 0) {
        randomizeTiles();
      }
    }

    function startHopping() {
      if (hopTimer) clearInterval(hopTimer);
      hopping = true;
      
      // Resume board marquee animation
      if (board) board.style.animationPlayState = "running";
      
      // Remove just-selected highlight from all tiles
      tiles.forEach(t => {
        if (t) {
          t.classList.remove("just-selected");
          
          if (t.classList.contains("selected") || t.classList.contains("disabled")) {
            t.style.opacity = "0.2"; // selected and disabled stay dim
          } else {
            t.style.opacity = "1"; // active tiles return to bright
          }
        }
      });
      
      hopTimer = setInterval(() => {
        hopOnce();
      }, hopIntervalMs);
    }

    function stopHopping() {
      hopping = false;
      if (hopTimer) {
        clearInterval(hopTimer);
        hopTimer = null;
      }
    }

    function stopAndSelect() {
      if (!hopping) return;
      stopHopping();
      
      // Check if gremlin hit
      if (activeIdx === gremlinIdx) {
        // Gremlin hit! Pause but don't select
        playCackle();
        tiles.forEach(t => t.classList.remove("active"));
        return;
      }
      
      playSelect();
      selectOption(activeIdx);
      tiles.forEach(t => t.classList.remove("active"));
    }

    function resetAll() {
      if (hopTimer) {
        clearInterval(hopTimer);
        hopTimer = null;
      }
      hopping = false;
      selectedOptionIds = new Set();
      tiles.forEach(t => {
        if (t) {
          t.classList.remove("disabled", "selected", "active", "gremlin");
        }
      });
      assignTitles();
      renderDisabled();
      activeIdx = 0;
      setActive(activeIdx);
      placeGremlinRandom();
      hopCount = 0;
      startHopping();
    }

    function toggleMute() {
      muted = !muted;
      updateMuteUI();
    }

    function updateMuteUI() {
      const muteBtn = document.getElementById("muteBtn");
      if (muteBtn) {
        muteBtn.textContent = muted ? "Sound: Off" : "Sound: On";
      }
    }

    function saveConfig(cfg) {
      localStorage.setItem(STORAGE_KEY, JSON.stringify(cfg));
    }

    function showConfig() {
      const panel = document.getElementById("configPanel");
      const configText = document.getElementById("configText");
      panel.classList.add("visible");
      configText.value = JSON.stringify(config, null, 2);
    }

    function hideConfig() {
      const panel = document.getElementById("configPanel");
      panel.classList.remove("visible");
    }

    function toggleHeader() {
      const header = document.getElementById("uiHeader");
      if (header) {
        header.style.display = (header.style.display === "none" || header.style.display === "") ? "flex" : "none";
      }
    }

    // Config panel controls
    document.getElementById("configClose").addEventListener("click", hideConfig);
    document.getElementById("configReset").addEventListener("click", () => {
      config = structuredClone(DEFAULT_CONFIG);
      centerImg.src = config.centerImageUrl;
      saveConfig(config);
      document.getElementById("configText").value = JSON.stringify(config, null, 2);
      assignTitles();
    });
    document.getElementById("configSave").addEventListener("click", async () => {
      try {
        const next = JSON.parse(document.getElementById("configText").value);
        if (!next.options || next.options.length !== 6) {
          alert("Config must contain exactly 6 options.");
          return;
        }
        config = next;
        saveConfig(config);
        centerImg.src = config.centerImageUrl || "";
        assignTitles();
        // Reload cackle audio if configured
        if (config.gremlin && config.gremlin.cackleAudioUrl) {
          await loadCackleAudio(config.gremlin.cackleAudioUrl);
        } else {
          cackleAudioBuffer = null;
        }
        hideConfig();
      } catch (e) {
        alert("Invalid JSON");
      }
    });

    // Mute button
    document.getElementById("muteBtn").addEventListener("click", toggleMute);

    // Camera button
    document.getElementById("cameraBtn").addEventListener("click", toggleCamera);

    // Keyboard controls
    window.addEventListener("keydown", (e) => {
      const panel = document.getElementById("configPanel");
      if (panel.classList.contains("visible")) {
        if (e.key === "Escape") {
          hideConfig();
        }
        return;
      }

      if (e.key === " ") {
        e.preventDefault();
        if (selectedOptionIds.size >= 6) return; // all done
        if (hopping) {
          stopAndSelect();
        } else {
          startHopping();
        }
      } else if (e.key.toLowerCase() === "r") {
        e.preventDefault();
        resetAll();
      } else if (e.key.toLowerCase() === "m" || e.key.toLowerCase() === "s") {
        e.preventDefault();
        toggleMute();
      } else if (e.key.toLowerCase() === "e") {
        e.preventDefault();
        showConfig();
      } else if (e.key.toLowerCase() === "c") {
        e.preventDefault();
        toggleCamera();
      } else if (e.key.toLowerCase() === "h") {
        e.preventDefault();
        toggleHeader();
      }
    });

    // Start overlay
    const startOverlay = document.getElementById("startOverlay");
    startOverlay.addEventListener("click", () => {
      ensureAudio();
      startOverlay.classList.add("hidden");
      startHopping();
    });

    // Board lights generation
    function generateBoardLights() {
      const boardLightsContainer = document.getElementById('boardLights');
      if (!boardLightsContainer) return;
      
      boardLightsContainer.innerHTML = '';
      const width = boardLightsContainer.offsetWidth;
      const height = boardLightsContainer.offsetHeight;
      const spacing = Math.min(width, height) * 0.05; // Responsive spacing
      const offset = 10; // Distance from outer edge of container

      const lights = [];

      // Top edge
      for (let x = offset; x < width - offset; x += spacing) {
        lights.push(createBoardLight(x, offset));
      }

      // Right edge
      for (let y = offset; y < height - offset; y += spacing) {
        lights.push(createBoardLight(width - offset, y));
      }

      // Bottom edge
      for (let x = width - offset; x > offset; x -= spacing) {
        lights.push(createBoardLight(x, height - offset));
      }

      // Left edge
      for (let y = height - offset; y > offset; y -= spacing) {
        lights.push(createBoardLight(offset, y));
      }

      // Add all lights with staggered animation
      lights.forEach((light, index) => {
        light.style.animationDelay = `${(index * 0.1) % 1.2}s`;
        boardLightsContainer.appendChild(light);
      });
    }

    function createBoardLight(x, y) {
      const light = document.createElement('div');
      light.className = 'board-light';
      light.style.left = `${x}px`;
      light.style.top = `${y}px`;
      return light;
    }

    // Initialize
    (async () => {
      await tryLoadDefaultFromConfigJson();
      config = loadConfig();
      centerImg.src = config.centerImageUrl || "";
      assignTitles();
      renderDisabled();
      setActive(activeIdx);
      placeGremlinRandom();
      updateMuteUI();
      // Load cackle audio if configured
      if (config.gremlin && config.gremlin.cackleAudioUrl) {
        await loadCackleAudio(config.gremlin.cackleAudioUrl);
      }
      // Generate board lights after DOM is fully rendered
      setTimeout(() => {
        generateBoardLights();
      }, 100);
      // Regenerate lights on window resize
      let resizeTimeout;
      window.addEventListener('resize', () => {
        clearTimeout(resizeTimeout);
        resizeTimeout = setTimeout(generateBoardLights, 100);
      });
      // Cleanup camera when page is closed
      window.addEventListener('beforeunload', () => {
        if (cameraActive) {
          stopCamera();
        }
      });
      // Don't auto-start; wait for user click
    })();
  </script>
</body>
</html>

