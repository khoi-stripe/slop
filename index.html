<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Slop Karaoke</title>
  <style>
    * { box-sizing: border-box; }
    html, body { height: 100%; margin: 0; overflow: hidden; }
    body {
      font-family: ui-sans-serif, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      background: #c1121f;
      color: #e8ecf6;
    }

    .app {
      width: 100vw;
      height: 100vh;
      padding: clamp(8px, 1.5cqi, 24px);
      display: grid;
      place-items: center;
      /* Enable container queries */
      container-type: size;
    }

    .board {
      display: grid;
      grid-template-columns: repeat(6, 1fr);
      grid-template-rows: repeat(5, 1fr);
      gap: clamp(6px, 1cqi, 16px);
      padding: clamp(4px, 0.6cqi, 12px);
      /* Fit within container, maintaining 16:9, reduced for bulb border */
      max-height: calc(100% - 48px);
      max-width: calc(100% - 48px);
      width: min(calc(100% - 48px), calc((100cqh - 48px) * (16 / 9)));
      height: min(calc(100% - 48px), calc((100cqw - 48px) * (9 / 16)));
      aspect-ratio: 16 / 9;
      position: relative; /* for config panel positioning */
      border-radius: 12px;
    }

    /* Marquee bulbs wrapper */
    .board::before {
      content: '';
      position: absolute;
      inset: -30px;
      pointer-events: none;
      z-index: 10;
      background-image:
        /* Top row */
        radial-gradient(circle, currentColor 10px, transparent 10px),
        radial-gradient(circle, currentColor 10px, transparent 10px),
        radial-gradient(circle, currentColor 10px, transparent 10px),
        radial-gradient(circle, currentColor 10px, transparent 10px),
        radial-gradient(circle, currentColor 10px, transparent 10px),
        radial-gradient(circle, currentColor 10px, transparent 10px),
        radial-gradient(circle, currentColor 10px, transparent 10px),
        radial-gradient(circle, currentColor 10px, transparent 10px),
        /* Right column */
        radial-gradient(circle, currentColor 10px, transparent 10px),
        radial-gradient(circle, currentColor 10px, transparent 10px),
        radial-gradient(circle, currentColor 10px, transparent 10px),
        radial-gradient(circle, currentColor 10px, transparent 10px),
        radial-gradient(circle, currentColor 10px, transparent 10px),
        /* Bottom row */
        radial-gradient(circle, currentColor 10px, transparent 10px),
        radial-gradient(circle, currentColor 10px, transparent 10px),
        radial-gradient(circle, currentColor 10px, transparent 10px),
        radial-gradient(circle, currentColor 10px, transparent 10px),
        radial-gradient(circle, currentColor 10px, transparent 10px),
        radial-gradient(circle, currentColor 10px, transparent 10px),
        radial-gradient(circle, currentColor 10px, transparent 10px),
        radial-gradient(circle, currentColor 10px, transparent 10px),
        /* Left column */
        radial-gradient(circle, currentColor 10px, transparent 10px),
        radial-gradient(circle, currentColor 10px, transparent 10px),
        radial-gradient(circle, currentColor 10px, transparent 10px),
        radial-gradient(circle, currentColor 10px, transparent 10px),
        radial-gradient(circle, currentColor 10px, transparent 10px);
      background-size: 20px 20px;
      background-repeat: no-repeat;
      background-position:
        /* Top row - evenly spaced */
        10% 0, 20% 0, 30% 0, 40% 0, 50% 0, 60% 0, 70% 0, 80% 0,
        /* Right column */
        100% 20%, 100% 40%, 100% 60%, 100% 80%, 100% 100%,
        /* Bottom row */
        10% 100%, 20% 100%, 30% 100%, 40% 100%, 50% 100%, 60% 100%, 70% 100%, 80% 100%,
        /* Left column */
        0 20%, 0 40%, 0 60%, 0 80%, 0 100%;
      filter: drop-shadow(0 0 12px currentColor);
      animation: bulbsFlash 0.6s linear infinite;
    }

    @keyframes bulbsFlash {
      0%, 100% { color: #FFFFFF; }
      50% { color: #FFD700; }
    }

    .tile {
      background: rgba(0,0,0,0.1);
      border: none;
      border-radius: 8px;
      display: grid;
      place-items: center;
      text-align: center;
      padding: clamp(8px, 1.5cqi, 24px);
      font-size: clamp(14px, 1.25cqi, 40px);
      font-weight: 700;
      line-height: 1.2;
      transition: box-shadow 120ms ease, transform 80ms ease, background 180ms ease, opacity 180ms ease;
      position: relative; /* needed for absolute positioned gremlin */
    }

    .tile.active {
      box-shadow: 0 0 0 3px rgba(251,191,36,0.45), 0 0 24px 4px rgba(245,158,11,0.35);
      background: rgba(255,255,255,0.15);
      border: 4px solid #F59E34;
    }

    .tile.selected {
      /* Matches unselected tile style - no special styling */
    }

    .tile.just-selected {
      background: #E1B033;
      color: #000000;
    }

    .tile.disabled {
      opacity: 0.2;
    }

    .tile.disabled.selected {
      opacity: 1; /* selected tile stays fully visible */
    }

    /* Gremlin overlay */
    .tile .gremlin-img {
      display: none;
      position: absolute;
      inset: 0; /* fill entire tile */
      width: 100%;
      height: 100%;
      object-fit: cover;
      border-radius: 8px;
      z-index: 10;
    }

    .tile.gremlin .gremlin-img {
      display: block;
    }

    .tile.gremlin .tile-text {
      display: none;
    }

    .center {
      grid-column: 2 / span 4;
      grid-row: 2 / span 3;
      background: radial-gradient(circle, #1c2347, #12162a);
      border: none;
      border-radius: 8px;
      padding: 0;
      overflow: hidden;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    .center img {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    /* Start overlay */
    #startOverlay {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.9);
      display: grid;
      place-items: center;
      z-index: 1000;
      cursor: pointer;
    }

    #startOverlay .message {
      font-size: 32px;
      font-weight: 700;
      color: #E1B033;
      text-align: center;
      padding: 32px;
    }

    #startOverlay.hidden {
      display: none;
    }

    /* UI Elements */
    .header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      font-size: clamp(10px, 1.2cqi, 16px);
      color: rgba(255,255,255,0.7);
    }

    .kbd {
      background: rgba(255,255,255,0.06);
      border: 1px solid rgba(255,255,255,0.15);
      border-bottom-width: 2px;
      padding: 1px 6px;
      border-radius: 8px;
      color: #cbd5e1;
      font-size: clamp(10px, 1cqi, 14px);
      font-weight: 600;
    }

    .btn {
      background: #1a2144;
      color: #e8ecf6;
      border: 1px solid #2a3568;
      padding: 4px 8px;
      border-radius: 8px;
      cursor: pointer;
      font-size: clamp(10px, 1cqi, 14px);
    }

    .btn:hover {
      border-color: #3a4a86;
    }

    /* Config panel */
    .config-panel {
      position: absolute;
      inset: 16px;
      background: rgba(10,12,20,0.95);
      border: 1px solid #2a3568;
      border-radius: 8px;
      padding: 16px;
      display: none;
      grid-template-rows: auto 1fr auto;
      gap: 12px;
      z-index: 100;
    }

    .config-panel.visible {
      display: grid;
    }

    .config-panel textarea {
      width: 100%;
      height: 100%;
      resize: none;
      background: #0f1428;
      color: #e8ecf6;
      border: 1px solid #27315c;
      border-radius: 8px;
      padding: 12px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      font-size: 12px;
    }

    .config-panel .row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 8px;
    }

    .config-panel .title {
      font-weight: 700;
      font-size: 16px;
    }
  </style>
</head>
<body>
  <div id="startOverlay">
    <div class="message">Click to Start</div>
  </div>
  <div class="app">
    <div class="header" id="uiHeader" style="display:none;">
      <div>
        <span>Space: <span class="kbd">stop/select</span></span>
        <span style="margin-left:10px;">R: <span class="kbd">reset</span></span>
        <span style="margin-left:10px;">E: <span class="kbd">edit config</span></span>
        <button class="btn" id="muteBtn" style="margin-left:10px;">Sound: On</button>
      </div>
    </div>

    <div class="board" id="board">
      <!-- Perimeter tiles -->
      <div class="tile" style="grid-column: 1; grid-row: 1;">1</div>
      <div class="tile" style="grid-column: 2; grid-row: 1;">2</div>
      <div class="tile" style="grid-column: 3; grid-row: 1;">3</div>
      <div class="tile" style="grid-column: 4; grid-row: 1;">4</div>
      <div class="tile" style="grid-column: 5; grid-row: 1;">5</div>
      <div class="tile" style="grid-column: 6; grid-row: 1;">6</div>
      
      <div class="tile" style="grid-column: 6; grid-row: 2;">7</div>
      <div class="tile" style="grid-column: 6; grid-row: 3;">8</div>
      <div class="tile" style="grid-column: 6; grid-row: 4;">9</div>
      
      <div class="tile" style="grid-column: 6; grid-row: 5;">10</div>
      <div class="tile" style="grid-column: 5; grid-row: 5;">11</div>
      <div class="tile" style="grid-column: 4; grid-row: 5;">12</div>
      <div class="tile" style="grid-column: 3; grid-row: 5;">13</div>
      <div class="tile" style="grid-column: 2; grid-row: 5;">14</div>
      <div class="tile" style="grid-column: 1; grid-row: 5;">15</div>
      
      <div class="tile" style="grid-column: 1; grid-row: 4;">16</div>
      <div class="tile" style="grid-column: 1; grid-row: 3;">17</div>
      <div class="tile" style="grid-column: 1; grid-row: 2;">18</div>
      
      <!-- Center tile -->
      <div class="center" id="center">
        <img id="centerImage" alt="Center" />
      </div>

      <!-- Config panel -->
      <div class="config-panel" id="configPanel">
        <div class="row">
          <div class="title">Configuration (JSON)</div>
          <div>
            <button class="btn" id="configClose">Close (Esc)</button>
            <button class="btn" id="configReset">Reset to Defaults</button>
            <button class="btn" id="configSave">Save</button>
          </div>
        </div>
        <textarea id="configText"></textarea>
        <div class="row">
          <div style="font-size:12px; color: rgba(255,255,255,0.5);">Changes persist in your browser</div>
        </div>
      </div>
    </div>
  </div>

  <script>
    // Configuration system
    let DEFAULT_CONFIG = {
      centerImageUrl: "images/gremlin_center.png",
      gremlin: { title: "AI Gremlin", imageUrl: "images/gremlin.png", cackleAudioUrl: "" },
      options: [
        { id: "A", title: "Option A" },
        { id: "B", title: "Option B" },
        { id: "C", title: "Option C" },
        { id: "D", title: "Option D" },
        { id: "E", title: "Option E" },
        { id: "F", title: "Option F" }
      ]
    };

    const STORAGE_KEY = "pyl_config_v2";

    async function tryLoadDefaultFromConfigJson() {
      try {
        const res = await fetch('./config.json', { cache: 'no-store' });
        if (!res.ok) return;
        const json = await res.json();
        if (!json || !Array.isArray(json.options) || json.options.length !== 6) return;
        DEFAULT_CONFIG = json;
      } catch {}
    }

    function loadConfig() {
      try {
        const raw = localStorage.getItem(STORAGE_KEY);
        if (!raw) return structuredClone(DEFAULT_CONFIG);
        const cfg = JSON.parse(raw);
        if (!cfg.options || cfg.options.length !== 6) return structuredClone(DEFAULT_CONFIG);
        return cfg;
      } catch (e) {
        return structuredClone(DEFAULT_CONFIG);
      }
    }

    let config;
    const centerImg = document.getElementById("centerImage");

    // Get all perimeter tiles (numbered 1-18)
    const tiles = [];
    for (let i = 1; i <= 18; i++) {
      const tile = document.querySelector(`.tile:nth-child(${i})`);
      if (tile) tiles.push(tile);
    }

    function assignTitles() {
      // Assign 6 options to 18 tiles (3 tiles per option)
      const optionIds = config.options.map(o => o.id);
      const indices = Array.from({length: 18}, (_, i) => i);
      // Shuffle
      for (let i = indices.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [indices[i], indices[j]] = [indices[j], indices[i]];
      }
      
      const byId = Object.fromEntries(config.options.map(o => [o.id, o]));
      
      for (let k = 0; k < optionIds.length; k++) {
        for (let rep = 0; rep < 3; rep++) {
          const tileIdx = indices[k * 3 + rep];
          const tile = tiles[tileIdx];
          const opt = byId[optionIds[k]];
          
          // Wrap text in span for gremlin hiding
          const textSpan = document.createElement('span');
          textSpan.className = 'tile-text';
          textSpan.textContent = opt.title;
          tile.textContent = '';
          tile.appendChild(textSpan);
          
          // Add gremlin image holder
          const gimg = document.createElement('img');
          gimg.className = 'gremlin-img';
          gimg.src = config.gremlin?.imageUrl || '';
          tile.appendChild(gimg);
          
          tile.dataset.optionId = optionIds[k];
        }
      }
    }

    // Game state
    let selectedOptionIds = new Set(); // options that have been selected
    let activeIdx = 0; // current active tile index
    let hopping = false;
    let hopTimer = null;
    let hopIntervalMs = 160;
    let gremlinIdx = -1; // current gremlin tile index
    let hopCount = 0;

    function setActive(idx) {
      tiles.forEach((t, i) => {
        if (t) t.classList.toggle("active", i === idx);
      });
    }

    function renderDisabled() {
      tiles.forEach((t) => {
        if (!t) return;
        const disabled = selectedOptionIds.has(t.dataset.optionId);
        t.classList.toggle("disabled", disabled);
      });
    }

    function selectOption(tileIdx) {
      const tile = tiles[tileIdx];
      if (!tile) return;
      const optId = tile.dataset.optionId;
      if (selectedOptionIds.has(optId)) return; // already selected
      
      selectedOptionIds.add(optId);
      tile.classList.add("selected", "just-selected");
      renderDisabled();
      
      // Dim ALL tiles to 20% first (including previously selected)
      tiles.forEach(t => {
        if (t) {
          t.style.opacity = "0.2";
        }
      });
      
      // Then brighten only the tile just selected
      tile.style.opacity = "1";
    }

    function placeGremlinRandom() {
      // Choose a tile index not currently disabled by selection
      const candidates = [];
      for (let i = 0; i < tiles.length; i++) {
        if (tiles[i] && !selectedOptionIds.has(tiles[i].dataset.optionId)) {
          candidates.push(i);
        }
      }
      if (candidates.length === 0) {
        gremlinIdx = -1;
        return;
      }
      gremlinIdx = candidates[Math.floor(Math.random() * candidates.length)];
      tiles.forEach((t, i) => {
        if (t) t.classList.toggle("gremlin", i === gremlinIdx);
      });
    }

    // Audio
    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    let muted = false;
    let cackleAudioBuffer = null;

    function ensureAudio() {
      try {
        if (audioCtx.state === "suspended") audioCtx.resume();
      } catch {}
    }

    async function loadCackleAudio(url) {
      if (!url) {
        cackleAudioBuffer = null;
        return;
      }
      try {
        ensureAudio();
        const response = await fetch(url);
        const arrayBuffer = await response.arrayBuffer();
        cackleAudioBuffer = await audioCtx.decodeAudioData(arrayBuffer);
      } catch (e) {
        console.error("Failed to load cackle audio:", e);
        cackleAudioBuffer = null;
      }
    }

    function playBleep() {
      if (muted) return;
      try {
        ensureAudio();
        const o = audioCtx.createOscillator();
        const g = audioCtx.createGain();
        o.type = "square";
        o.frequency.value = 600 + Math.random() * 200;
        g.gain.value = 0.05;
        o.connect(g).connect(audioCtx.destination);
        o.start();
        o.stop(audioCtx.currentTime + 0.06);
      } catch {}
    }

    function playSelect() {
      if (muted) return;
      try {
        ensureAudio();
        const o = audioCtx.createOscillator();
        const g = audioCtx.createGain();
        o.type = "triangle";
        o.frequency.setValueAtTime(220, audioCtx.currentTime);
        o.frequency.linearRampToValueAtTime(880, audioCtx.currentTime + 0.25);
        g.gain.setValueAtTime(0.08, audioCtx.currentTime);
        g.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + 0.35);
        o.connect(g).connect(audioCtx.destination);
        o.start();
        o.stop(audioCtx.currentTime + 0.4);
      } catch {}
    }

    function playCackle() {
      if (muted) return;
      try {
        ensureAudio();
        
        // If we have a loaded audio file, play it
        if (cackleAudioBuffer) {
          const source = audioCtx.createBufferSource();
          source.buffer = cackleAudioBuffer;
          const gain = audioCtx.createGain();
          gain.gain.value = 1.0;
          source.connect(gain).connect(audioCtx.destination);
          source.start();
          return;
        }
        
        // Otherwise, fall back to synthetic cackle
        const now = audioCtx.currentTime;
        for (let i = 0; i < 8; i++) {
          const start = now + i * 0.06;
          const o = audioCtx.createOscillator();
          const g = audioCtx.createGain();
          o.type = "square";
          const base = 380 + Math.random() * 320;
          o.frequency.setValueAtTime(base, start);
          o.frequency.exponentialRampToValueAtTime(base * 0.6, start + 0.05);
          g.gain.setValueAtTime(0.09, start);
          g.gain.exponentialRampToValueAtTime(0.0001, start + 0.08);
          o.connect(g).connect(audioCtx.destination);
          o.start(start);
          o.stop(start + 0.09);
        }
      } catch {}
    }

    function hopOnce() {
      // Move to next enabled tile clockwise
      let next = activeIdx;
      for (let step = 0; step < tiles.length; step++) {
        next = (next + 1) % tiles.length;
        const t = tiles[next];
        if (t && !selectedOptionIds.has(t.dataset.optionId)) {
          activeIdx = next;
          setActive(activeIdx);
          playBleep();
          break;
        }
      }
      // Move gremlin every 6th hop
      hopCount = (hopCount + 1) % 6;
      if (hopCount === 0) placeGremlinRandom();
    }

    function startHopping() {
      if (hopTimer) clearInterval(hopTimer);
      hopping = true;
      
      // Remove just-selected highlight from all tiles
      tiles.forEach(t => {
        if (t) {
          t.classList.remove("just-selected");
          
          if (t.classList.contains("selected") || t.classList.contains("disabled")) {
            t.style.opacity = "0.2"; // selected and disabled stay dim
          } else {
            t.style.opacity = "1"; // active tiles return to bright
          }
        }
      });
      
      hopTimer = setInterval(() => {
        hopOnce();
      }, hopIntervalMs);
    }

    function stopHopping() {
      hopping = false;
      if (hopTimer) {
        clearInterval(hopTimer);
        hopTimer = null;
      }
    }

    function stopAndSelect() {
      if (!hopping) return;
      stopHopping();
      
      // Check if gremlin hit
      if (activeIdx === gremlinIdx) {
        // Gremlin hit! Pause but don't select
        playCackle();
        tiles.forEach(t => t.classList.remove("active"));
        return;
      }
      
      playSelect();
      selectOption(activeIdx);
      tiles.forEach(t => t.classList.remove("active"));
    }

    function resetAll() {
      if (hopTimer) {
        clearInterval(hopTimer);
        hopTimer = null;
      }
      hopping = false;
      selectedOptionIds = new Set();
      tiles.forEach(t => {
        if (t) {
          t.classList.remove("disabled", "selected", "active", "gremlin");
        }
      });
      assignTitles();
      renderDisabled();
      activeIdx = 0;
      setActive(activeIdx);
      placeGremlinRandom();
      hopCount = 0;
      startHopping();
    }

    function toggleMute() {
      muted = !muted;
      updateMuteUI();
    }

    function updateMuteUI() {
      const muteBtn = document.getElementById("muteBtn");
      if (muteBtn) {
        muteBtn.textContent = muted ? "Sound: Off" : "Sound: On";
      }
    }

    function saveConfig(cfg) {
      localStorage.setItem(STORAGE_KEY, JSON.stringify(cfg));
    }

    function showConfig() {
      const panel = document.getElementById("configPanel");
      const configText = document.getElementById("configText");
      panel.classList.add("visible");
      configText.value = JSON.stringify(config, null, 2);
    }

    function hideConfig() {
      const panel = document.getElementById("configPanel");
      panel.classList.remove("visible");
    }

    function toggleHeader() {
      const header = document.getElementById("uiHeader");
      if (header) {
        header.style.display = (header.style.display === "none" || header.style.display === "") ? "flex" : "none";
      }
    }

    // Config panel controls
    document.getElementById("configClose").addEventListener("click", hideConfig);
    document.getElementById("configReset").addEventListener("click", () => {
      config = structuredClone(DEFAULT_CONFIG);
      centerImg.src = config.centerImageUrl;
      saveConfig(config);
      document.getElementById("configText").value = JSON.stringify(config, null, 2);
      assignTitles();
    });
    document.getElementById("configSave").addEventListener("click", async () => {
      try {
        const next = JSON.parse(document.getElementById("configText").value);
        if (!next.options || next.options.length !== 6) {
          alert("Config must contain exactly 6 options.");
          return;
        }
        config = next;
        saveConfig(config);
        centerImg.src = config.centerImageUrl || "";
        assignTitles();
        // Reload cackle audio if configured
        if (config.gremlin && config.gremlin.cackleAudioUrl) {
          await loadCackleAudio(config.gremlin.cackleAudioUrl);
        } else {
          cackleAudioBuffer = null;
        }
        hideConfig();
      } catch (e) {
        alert("Invalid JSON");
      }
    });

    // Mute button
    document.getElementById("muteBtn").addEventListener("click", toggleMute);

    // Keyboard controls
    window.addEventListener("keydown", (e) => {
      const panel = document.getElementById("configPanel");
      if (panel.classList.contains("visible")) {
        if (e.key === "Escape") {
          hideConfig();
        }
        return;
      }

      if (e.key === " ") {
        e.preventDefault();
        if (selectedOptionIds.size >= 6) return; // all done
        if (hopping) {
          stopAndSelect();
        } else {
          startHopping();
        }
      } else if (e.key.toLowerCase() === "r") {
        e.preventDefault();
        resetAll();
      } else if (e.key.toLowerCase() === "m" || e.key.toLowerCase() === "s") {
        e.preventDefault();
        toggleMute();
      } else if (e.key.toLowerCase() === "e") {
        e.preventDefault();
        showConfig();
      } else if (e.key.toLowerCase() === "h") {
        e.preventDefault();
        toggleHeader();
      }
    });

    // Start overlay
    const startOverlay = document.getElementById("startOverlay");
    startOverlay.addEventListener("click", () => {
      ensureAudio();
      startOverlay.classList.add("hidden");
      startHopping();
    });

    // Initialize
    (async () => {
      await tryLoadDefaultFromConfigJson();
      config = loadConfig();
      centerImg.src = config.centerImageUrl || "";
      assignTitles();
      renderDisabled();
      setActive(activeIdx);
      placeGremlinRandom();
      updateMuteUI();
      // Load cackle audio if configured
      if (config.gremlin && config.gremlin.cackleAudioUrl) {
        await loadCackleAudio(config.gremlin.cackleAudioUrl);
      }
      // Don't auto-start; wait for user click
    })();
  </script>
</body>
</html>

